# ❌ 오답 노트 – 카카오 선물하기 문제

## 1. 문제 접근 방식

1. `giftBox[i][j]`를 이용해 i가 j에게 준 선물 수를 저장하고
2. `sendMap` / `receivedMap`으로 선물 지수를 계산한 뒤
3. 각 친구 i에 대해 다른 모든 친구 j를 돌며 다음 달에 i가 선물을 받는 경우를 nextGift로 누적하는 방식으로 구현.

구조 자체는 문제 설명과 크게 어긋나지 않는다고 생각.

---

## 2. 실제 오답 원인

가장 큰 문제는 쌍(i, j)을 다루는 방식.

이 문제는 두 사람(i, j) 사이의 관계를 딱 한 번만 판단해서 누가 받는지 정해야 하는 문제인데,

내 코드는

(i, j)와 (j, i)를 각각 독립적으로 판단했고
i가 받는 경우만을 기준으로 카운트하는 구조였다.

그 결과,

`giftBox[i][j] - giftBox[j][i] < 0`
(즉, 사실은 j가 더 많이 준 경우)에도
선물 지수 비교로 다시 판정을 해버리는 흐름이 생겼다.

이로 인해 이미 결과가 정해진 쌍에서도
원래 받으면 안 되는 사람이 추가로 선물을 받는 상황이 발생했다.

테스트 1에서는 이 현상이 실제로 드러나
한 쌍에서 1개가 과하게 카운트되어 결과가 3으로 튀었다.

---

## 3. 왜 다른 테스트는 통과했는가

테스트 2, 3은 선물 지수 차이가 명확하거나 주고받은 기록이 균형적이어서
쌍 판정이 중복되더라도 최대값(answer)에 영향을 주지 않는 구조였다.

즉, 로직이 맞아서 통과한 게 아니라, 운 좋게 버그가 드러나지 않았을 뿐이다.

--- 
## 4. 핵심 교훈

“한 사람 기준으로 전부 비교하며 누적”하는 방식은
쌍 판정 문제에서 중복/뒤집힘 버그를 만들기 쉽다.

이런 문제는 반드시 (i, j)를 한 번만 판단하고
결과를 승자에게 바로 분배하는 방식으로 풀어야 한다.

--- 
## 5. 올바른 접근 정리

1. 이름 → 인덱스 매핑
2. cnt[i][j]: i가 j에게 준 선물 수
3. giftIndex[i] = 준 선물 수 - 받은 선물 수

모든 i < j 쌍에 대해:
4. 더 많이 준 사람이 +1
5. 같으면 선물 지수 비교
6. 그것도 같으면 아무도 받지 않음
7. 최댓값 반환

---
## 6. 더 나은 해법

### A. 규칙을 쌍(i, j) 기준으로 1번만 결정한다
이 문제는 본질이 두 사람 사이 관계를 한 번만 판정. 

- i와 j 사이에서 다음 달 누가 받는지는 “한 번” 결정됨
- 그 결정을 받는 사람에게 +1만 하면 끝

정답 코드는 for (i) for (j=i+1)로 각 쌍을 딱 한 번만 판단해서, 중복 판정/누락/뒤집힘이 구조적으로 불가능

반면 내 코드는 i 기준으로 모든 j를 돌면서 내가 받는지만 누적하는데,
이 방식은 실수하기 쉽다. 특히 상대가 더 많이 준 경우(diff<0) 처리에서 버그가 나면 바로 오답이 된다.

### B. diff(주고받은 기록) 판정이 3-way로 정확하다
문제 규칙은 3갈래다.

- cnt[i][j] > cnt[j][i] → i가 받음
- cnt[i][j] < cnt[j][i] → j가 받음
- cnt[i][j] == cnt[j][i] → 선물지수 비교

근데 내 코드는 지금 구조가
```
if (diff > 0) i가 받음
else 선물지수로 판단
```
즉, diff < 0인 상황(상대가 더 많이 준 상황)에서도 선물지수로 다시 판정을 해버린 것.

### C. 자료구조가 단순해서 실수/Null 위험이 줄어든다
정답 코드는 int[] give, receive, giftIndex, next로 끝나서

1. null 가능성 없음
2. getOrDefault 실수 없음
3. 로직 흐름이 명확함

반면 내 코드는 Map 2개를 쓰기 때문에(지금은 getOrDefault로 보완했지만) 원래는 NPE도 났고, 실수 여지도 더 많다.
