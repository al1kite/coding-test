# 코딩테스트 마스터 커리큘럼

> 목표: 알고리즘 기초부터 시작해서 코딩테스트 합격 수준까지 도달하기
> 언어: Java (기존 풀이 기준)
> 추천 플랫폼: 백준(BOJ), 프로그래머스

---

## 전체 로드맵

```
Phase 1 (기초 체력) → Phase 2 (핵심 알고리즘) → Phase 3 (실전 유형) → Phase 4 (심화/실전)
```

---

## Phase 1: 기초 체력 다지기

> 자료구조의 개념과 시간복잡도를 이해하는 단계

### 1-1. 시간복잡도 (Big-O)

**왜 배우나:** 내 코드가 시간 초과가 나는 이유를 알려면 필수
- O(1), O(N), O(N²), O(log N), O(N log N) 의 차이
- N이 10만이면 O(N²)은 터진다는 감각 익히기

| 입력 크기 (N) | 허용 가능한 시간복잡도 |
|--------------|---------------------|
| N ≤ 10       | O(N!), O(2^N)       |
| N ≤ 20       | O(2^N)              |
| N ≤ 100      | O(N³)               |
| N ≤ 1,000    | O(N²)               |
| N ≤ 100,000  | O(N log N)          |
| N ≤ 10,000,000 | O(N)             |

### 1-2. 기본 자료구조

| 자료구조 | 핵심 개념 | 추천 문제 (백준) |
|---------|---------|----------------|
| **배열** | 인덱스 접근, 순회 | 10818 (최소, 최대) ✅ |
| **문자열** | 문자 단위 처리 | 1157 (단어 공부) ✅ |
| **스택** | LIFO, 괄호 매칭 | 10828 (스택), 9012 (괄호) |
| **큐** | FIFO, BFS의 기반 | 10845 (큐), 2164 (카드2) |
| **해시맵** | Key-Value, 중복/존재 확인 | 1620 (나는야 포켓몬 마스터), 7785 (회사에 있는 사람) |
| **힙 (우선순위 큐)** | 최대/최소 빠르게 | 11279 (최대 힙) ✅, 1927 (최소 힙) |

> ✅ = 이미 풀어본 문제

### 1-3. 정렬

- Arrays.sort() 사용법
- Comparable / Comparator 커스텀 정렬
- 추천 문제: 1181 (단어 정렬), 10814 (나이순 정렬), 11650 (좌표 정렬하기)

---

## Phase 2: 핵심 알고리즘 (가장 중요!)

> 코딩테스트의 80%는 이 5개 유형에서 나온다

### 2-1. 완전탐색 (Brute Force)

**개념:** 가능한 모든 경우를 다 해보는 것
- 반복문 중첩
- 순열/조합 구현 (재귀)

```
추천 순서:
1. 2798 (블랙잭) - 3중 for문
2. 2503 (숫자 야구) ✅ - 조건 따지기
3. 14501 (퇴사) - 재귀로 모든 경우
4. 15649~15652 (N과 M 시리즈) - 순열/조합 재귀 연습 ★★★
```

### 2-2. BFS / DFS (그래프 탐색)

**개념:**
- DFS: 한 방향으로 끝까지 간 다음 돌아오기 (스택/재귀)
- BFS: 가까운 것부터 차례대로 탐색 (큐)
- "최단거리" → BFS / "모든 경우" → DFS

```
추천 순서:
1. 2606 (바이러스) ✅ - 기본 DFS/BFS
2. 2667 (단지번호붙이기) ✅ - 2차원 격자 탐색
3. 1260 (DFS와 BFS) - 둘 다 구현
4. 7576 (토마토) ✅ - BFS 응용
5. 1697 (숨바꼭질) ✅ - BFS로 최단거리
6. 2178 (미로 탐색) - BFS 최단경로
7. 7569 (토마토 3D) - 3차원 BFS
```

### 2-3. 동적 프로그래밍 (DP) ★★★ 가장 중요

**개념:** 큰 문제를 작은 문제로 나눠서 풀고, 결과를 저장해서 재활용
- 점화식 세우기가 핵심
- `dp[i] = dp[i-1] + dp[i-2]` 같은 패턴

```
추천 순서 (쉬운 것부터):
1. 1003 (피보나치 함수) - DP 입문
2. 9461 (파도반 수열) ✅ - 점화식 연습
3. 1463 (1로 만들기) - 최소 연산 DP
4. 11726 (2×n 타일링) - 경우의 수 DP
5. 12865 (평범한 배낭) - 0/1 배낭 문제 ★
6. 1932 (정수 삼각형) - 2차원 DP
7. 9251 (LCS) - 문자열 DP
8. 11053 (가장 긴 증가하는 부분 수열) - LIS ★
```

### 2-4. 그리디 (Greedy)

**개념:** 매 순간 가장 좋아 보이는 선택을 하는 것
- DP랑 헷갈리는데, 그리디는 "지금 당장 최선"이 "전체 최선"인 경우에만 사용

```
추천 순서:
1. 11047 (동전 0) - 그리디 입문
2. 1931 (회의실 배정) - 정렬 + 그리디 ★
3. 11399 (ATM) - 정렬 활용
4. 1541 (잃어버린 괄호) - 문자열 + 그리디
5. 13305 (주유소) - 그리디 응용
```

### 2-5. 이진탐색 (Binary Search)

**개념:** 정렬된 데이터에서 절반씩 줄여가며 찾기 → O(log N)
- "N이 크고 정렬 가능하면" 이진탐색 의심

```
추천 순서:
1. 1920 (수 찾기) - 기본 이진탐색
2. 10816 (숫자 카드 2) - lower/upper bound
3. 2805 (나무 자르기) - 매개변수 탐색 ★
4. 1654 (랜선 자르기) - 매개변수 탐색
5. 2110 (공유기 설치) - 매개변수 탐색 심화
```

---

## Phase 3: 실전 빈출 유형

### 3-1. 투포인터 / 슬라이딩 윈도우

**개념:** 두 개의 포인터를 이동시키며 구간 탐색 → O(N)

```
추천 순서:
1. 2003 (수들의 합 2) - 투포인터 입문
2. 1644 (소수의 연속합) - 투포인터
3. 2230 (수 고르기) - 정렬 + 투포인터
4. 12891 (DNA 비밀번호) - 슬라이딩 윈도우 (프로그래머스)
```

### 3-2. 최단경로

**개념:** 가중치 있는 그래프에서 최단거리
- 다익스트라: 한 점 → 모든 점 (양수 가중치)
- 플로이드: 모든 점 → 모든 점

```
추천 순서:
1. 1753 (최단경로) - 다익스트라 기본 ★
2. 1916 (최소비용 구하기) - 다익스트라
3. 11404 (플로이드) - 플로이드 기본
4. 1504 (특정한 최단 경로) - 다익스트라 응용
```

### 3-3. 유니온파인드 & 최소 스패닝 트리

```
추천 순서:
1. 1717 (집합의 표현) - 유니온파인드 기본
2. 1197 (최소 스패닝 트리) - 크루스칼
3. 4386 (별자리 만들기)
```

### 3-4. 구현 / 시뮬레이션

**개념:** 문제에서 시키는 대로 정확히 코딩하기
- 삼성 SW역량테스트에 자주 출제

```
추천 문제:
1. 14503 (로봇 청소기)
2. 14500 (테트로미노)
3. 15683 (감시)
4. 16236 (아기 상어) ✅
```

---

## Phase 4: 심화 (상위권 목표시)

| 유형 | 추천 문제 |
|-----|---------|
| 비트마스크 DP | 1562 (계단 수) ✅, 2098 (외판원 순회) |
| 위상정렬 | 2252 (줄 세우기), 1766 (문제집) |
| 세그먼트 트리 | 2042 (구간 합 구하기), 10868 (최솟값) |
| 트라이 | 5052 (전화번호 목록) |

---

## 공부 방법 가이드

### 하루 루틴 (추천)

```
1. 개념 학습 (30분)
   - 해당 알고리즘의 원리를 이해
   - 유튜브 추천: "바킹독 알고리즘", "안경잡이 개발자"

2. 예제 문제 풀기 (1~2시간)
   - 30분 고민 → 안 풀리면 풀이 참고 → 반드시 직접 다시 구현
   - 풀이를 봤더라도 "왜 이렇게 되는지" 이해하고 넘어가기

3. 복습 (15분)
   - 오늘 푼 문제의 핵심 아이디어 한 줄로 정리
```

### 핵심 원칙

1. **30분 룰**: 30분 고민해도 모르면 풀이를 본다. 시간 낭비하지 말 것.
2. **풀이를 봐도 OK**: 처음엔 당연히 못 푼다. 풀이를 보고 패턴을 익히는 것도 실력이다.
3. **같은 유형 반복**: 한 유형을 3~5문제 연속으로 풀어야 패턴이 몸에 배인다.
4. **틀린 문제 다시 풀기**: 1주일 후에 다시 풀어보면 진짜 이해했는지 확인 가능.
5. **코드를 외우지 말고 흐름을 외워라**: BFS면 "큐에 넣고 → 꺼내고 → 방문체크 → 인접노드 추가" 흐름.

### 주차별 계획

| 주차 | 학습 내용 | 목표 문제 수 |
|-----|---------|------------|
| 1주차 | 시간복잡도 + 스택/큐 | 6문제 |
| 2주차 | 정렬 + 해시맵 | 6문제 |
| 3주차 | 완전탐색 (재귀, 순열/조합) | 6문제 |
| 4주차 | BFS/DFS 기초 | 6문제 |
| 5주차 | BFS/DFS 응용 | 6문제 |
| 6주차 | DP 기초 (1차원) | 6문제 |
| 7주차 | DP 응용 (2차원, 배낭) | 6문제 |
| 8주차 | 그리디 | 6문제 |
| 9주차 | 이진탐색 + 매개변수 탐색 | 6문제 |
| 10주차 | 투포인터 / 슬라이딩 윈도우 | 5문제 |
| 11주차 | 최단경로 (다익스트라/플로이드) | 5문제 |
| 12주차 | 실전 모의고사 + 복습 | 5문제 |

**총 12주, 약 70문제로 코딩테스트 기본기 완성**

---

## 자주 쓰는 Java 코드 템플릿

### 입출력 (빠른 입력)
```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
    }
}
```

### BFS 템플릿
```java
int[] dx = {0, 0, 1, -1};
int[] dy = {1, -1, 0, 0};

Queue<int[]> queue = new LinkedList<>();
boolean[][] visited = new boolean[N][M];

queue.add(new int[]{startX, startY});
visited[startX][startY] = true;

while (!queue.isEmpty()) {
    int[] cur = queue.poll();
    for (int d = 0; d < 4; d++) {
        int nx = cur[0] + dx[d];
        int ny = cur[1] + dy[d];
        if (nx < 0 || ny < 0 || nx >= N || ny >= M) continue;
        if (visited[nx][ny]) continue;
        visited[nx][ny] = true;
        queue.add(new int[]{nx, ny});
    }
}
```

### DFS 템플릿 (재귀)
```java
boolean[] visited = new boolean[N];
List<List<Integer>> graph = new ArrayList<>();

void dfs(int node) {
    visited[node] = true;
    for (int next : graph.get(node)) {
        if (!visited[next]) {
            dfs(next);
        }
    }
}
```

### 이진탐색 템플릿
```java
int lo = 0, hi = maxValue;
while (lo <= hi) {
    int mid = (lo + hi) / 2;
    if (check(mid)) {
        lo = mid + 1; // 조건에 따라 lo/hi 조정
    } else {
        hi = mid - 1;
    }
}
```

---

> 이 커리큘럼은 현재 풀어본 47문제를 분석하여 부족한 영역 위주로 구성했습니다.
> Phase 2가 가장 중요합니다. 여기에 전체 시간의 60%를 투자하세요.
